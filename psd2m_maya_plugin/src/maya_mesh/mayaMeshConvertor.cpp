//----------------------------------------------------------------------------------------------
// ===============================================
//  Copyright (C) 2016, CDRIN.
//  All Rights Reserved.
// ===============================================
//  Unauthorized copying of this file, via any medium is strictly prohibited
//  Proprietary and confidential
//
//  @file MayaMeshConvertor.cpp
//  @author Fabien Raspail
//  @date 11-11-2016
//
//  @section DESCRIPTION
//
//----------------------------------------------------------------------------------------------

#include "mayaMeshConvertor.h"
#include "editorComponentGenerator.h"
#include "psd_reader/psdReader.h"

#if defined PSDTO3D_MAYA_VERSION
#include <maya/MObject.h>
#include <maya/MDagModifier.h>
#include <maya/MGlobal.h>
#include <maya/MItDependencyNodes.h>
#include <maya/MSelectionList.h>
#include <maya/MFnSet.h>
#else
#include "mayaStub.h"
#endif
#include <cassert>

// To disable optimization in a code revion, for debugging...
//#pragma optimize( "", off )
//#pragma optimize( "", on )


namespace maya_plugin
{

#pragma region CONSTRUCTOR
		MayaMeshGenerator::MayaMeshGenerator() : Impl(nullptr)
		{}

		MayaMeshGenerator::MayaMeshGenerator( MayaMeshGenerator& that )
		{
			this->Impl = that.Impl;
			that.Impl = nullptr;  // take ownership, no reference counting
		}

		MayaMeshGenerator::~MayaMeshGenerator()
		{
			if( Impl!=nullptr )
				delete Impl;
		}

// CONSTRUCTOR
#pragma endregion

#pragma region PUBLIC MAYA MESH GENERATOR

	//----------------------------------------------------------------------------------------
	// Creates a MayaMeshConvertor from DataMesh, if available in the DataSurface (preferred)
	// Creates a MayaMeshScriptor from DataSpline, if available in the DataSurface (alternate)
	MayaMeshGenerator MayaMeshGenerator::CreateMayaMeshGenerator(MDagModifier& dag, MObject& parent, const GraphLayer& graphLayer)
	{
		MayaMeshGenerator mayaMeshGenerator;
		if( graphLayer.Mesh.GetDataMesh() != nullptr )
		{
			mayaMeshGenerator.Impl = new MayaMeshConvertor(graphLayer);
			((MayaMeshConvertor*)(mayaMeshGenerator.Impl))->CreateMayaMFnMesh(parent);
		}
		else if( graphLayer.Mesh.GetDataSpline()!=nullptr )
		{
			mayaMeshGenerator.Impl = new MayaMeshScriptor();
			((MayaMeshScriptor*)(mayaMeshGenerator.Impl))->CreateMayaMFnMesh(dag, parent, graphLayer);
		}
		return mayaMeshGenerator;
	}

	//----------------------------------------------------------------------------------------
	MObject MayaMeshGenerator::GetMayaMObject()
	{
		if( Impl!=nullptr )
		{
			return Impl->GetMayaMObject();
		}
		// ERROR: should never happen
		assert( "ERROR: MayaMeshGenerator::GetMayaMObject(), Impl is null" == 0 );
		return MObject();
	}

	//----------------------------------------------------------------------------------------
	void MayaMeshGenerator::SetUvs()
	{
		if( Impl!=nullptr )
		{
			Impl->SetUvs();
			return;
		}
		// ERROR: should never happen
		assert( "ERROR: MayaMeshGenerator::SetUvs(), Impl is null" == 0 );
	}

	//----------------------------------------------------------------------------------------
	float MayaMeshGenerator::TransformToMayaCoordinates(float y)
	{
		return 1.f - y;
	}

// PUBLIC MAYA MESH GENERATOR
#pragma endregion

#pragma region PUBLIC MAYA MESH SCRIPTOR

	void PrintObject( MFnMesh& mesh )
	{
		MTypeId meshId = mesh.typeId();
		MString meshTypeName = mesh.typeName();
		MString meshName = mesh.name();
		MString meshAbsoluteName = mesh.absoluteName();
		const char* meshTypeNameStr = meshTypeName.asChar();
		const char* meshNameStr = meshName.asChar();
		const char* meshAbsoluteNameStr = meshAbsoluteName.asChar();
	}

	//----------------------------------------------------------------------------------------
	//
	// SPLINE CASE: Entire mesh is generated by the Maya from splines (aka Linear Mode), compare with Mesh case below
	//
	// Returns an empty Maya mesh object; usable immediately to set transform & materials
	// Generates a script to create geometry and splines later; resolves with dag.doIt()
	MObject MayaMeshScriptor::CreateMayaMFnMesh(MDagModifier& dag, MObject& parent, const GraphLayer& graphLayer)
	{
		const DataSpline& dataSpline = *(graphLayer.Mesh.GetDataSpline()); // surface should be a spline here
		float spacing = 0; // just zero, because object spacing is set elsewhere at the transform level
		float polycount = dataSpline.GetPrecision();
		boundsUV bounds = dataSpline.GetBoundsUV();
        float aspect = dataSpline.GetWidth() / dataSpline.GetHeight();

		float scale = graphLayer.Scale;
        scale *= this->BasedScaleFactor;
		float scaleX = scale * aspect;
		float scaleY = scale;

		// Get list of existing transform node names
		std::set<std::string> existingNodes; // std::set<MString> doesn't work, Maya API derp
		{
			MItDependencyNodes nodeItMesh(MFn::Type::kTransform, nullptr);
			for (; !nodeItMesh.isDone(); nodeItMesh.next())
			{
				#if MAYA_API_VERSION >= 20190000
				MFnTransform tmpTransform(nodeItMesh.thisNode());
				existingNodes.insert(std::string(tmpTransform.name().asChar()));
				#else
				MFnTransform tmpTransform(nodeItMesh.item());
				existingNodes.insert(std::string(tmpTransform.name().asChar()));
				#endif
			}
		}

		// STEP 1: Create an empty mesh object, resolves immediately
		std::string meshName = dataSpline.GetName(); // + std::string("_Mesh");
		const char* meshNameStr = meshName.data();
		// ALTERNATE 1a: Create using MFnMesh functions
		MFloatPointArray vertexArray;
		MIntArray polygonCounts;
		MIntArray polygonConnects;
		auto mesh = this->CurrentMesh.create( 0, 0, vertexArray, polygonCounts, polygonConnects, parent );
		// ALTERNATE 1b: Create using MFnDagNode functions, doesn't work
		//MFnDagNode& currentDagNode = this->CurrentMesh;
		//auto mesh = currentDagNode.create( MTypeId(MFn::kMesh), MString(meshNameStr), parent );
		CurrentObject = mesh;

		// STEP 2: Create a script with generates the splines, resolves with dag.doIt()

		//dag.commandToExecute("{ \n"); // open scope
		std::vector<std::string> splineNames;
		int splineNamesSize = 0;

		const std::vector<BezierCurve*> curves = dataSpline.GetCurves();
		for( int i=0; i<curves.size(); i++ )
		{
			int numPoints = curves[i]->GetPathSize();
			if( numPoints >= 2 ) // require at least bezier curve anchors
			{
				// reserve 40 chars max for "curve -bezier -d 3 -replace _Spline0001 ; " prefix and postfix
				// reserve 60 chars max for "-p 00000.0000000 00000.0000000 00000.0000000 -k 0000" each point
				// each anchor has three such points, and the first anchor must be included twice
				int cmdBufSize = 40 + (60*(numPoints+1)*3) + (int)strlen(meshNameStr);
				char* cmdBuf = new char[cmdBufSize];
				int pos = 0;

				// Example script command, circle with four anchor points
				// Note the first SegIn and the last SegOut vector are omitted from the -p list, but includes in the -k list
				//dag.commandToExecute("curve -bezier -d 3 -p -3 0 0 -p -3 0 2 -p -2 0 3 -p 0 0 3 -p 2 0 3 -p 3 0 2 -p 3 0 0 -p 3 0 -2 -p 2 0 -3 -p 0 0 -3 -p -2 0 -3 -p -3 0 -2 -p -3 0 0"
				//                     "-k 0 -k 0 -k 0 -k 1 -k 1 -k 1 -k 2 -k 2 -k 2 -k 3 -k 3 -k 3 -k 4 -k 4 -k 4");
				pos = _snprintf_s( cmdBuf, cmdBufSize, _TRUNCATE, "curve -bezier -d 3" );
				// Multiply x and y by scale
				PathPoints anchorFirst = curves[i]->GetPathPoints(0);
				pos += _snprintf_s( cmdBuf+pos, cmdBufSize-pos, _TRUNCATE, " -p %.7f %.7f %.7f", anchorFirst.AnchorPoint.x*scaleX, anchorFirst.AnchorPoint.y*scaleY, spacing );
				pos += _snprintf_s( cmdBuf+pos, cmdBufSize-pos, _TRUNCATE, " -p %.7f %.7f %.7f", anchorFirst.SegOut.x*scaleX, anchorFirst.SegOut.y*scaleY, spacing );
				for( int j=1; (j<numPoints) && (pos<cmdBufSize); j++ )
				{
					PathPoints anchor = curves[i]->GetPathPoints(j);
					pos += _snprintf_s( cmdBuf+pos, cmdBufSize-pos, _TRUNCATE, " -p %.7f %.7f %.7f", anchor.SegIn.x*scaleX, anchor.SegIn.y*scaleY, spacing );
					pos += _snprintf_s( cmdBuf+pos, cmdBufSize-pos, _TRUNCATE, " -p %.7f %.7f %.7f", anchor.AnchorPoint.x*scaleX, anchor.AnchorPoint.y*scaleY, spacing );
					pos += _snprintf_s( cmdBuf+pos, cmdBufSize-pos, _TRUNCATE, " -p %.7f %.7f %.7f", anchor.SegOut.x*scaleX, anchor.SegOut.y*scaleY, spacing );
				}
				pos += _snprintf_s( cmdBuf+pos, cmdBufSize-pos, _TRUNCATE, " -p %.7f %.7f %.7f", anchorFirst.SegIn.x*scaleX, anchorFirst.SegIn.y*scaleY, spacing );
				pos += _snprintf_s( cmdBuf+pos, cmdBufSize-pos, _TRUNCATE, " -p %.7f %.7f %.7f", anchorFirst.AnchorPoint.x*scaleX, anchorFirst.AnchorPoint.y*scaleY, spacing );
				for( int j=0; (j<(numPoints+1)) && (pos<cmdBufSize); j++ )
				{
					pos += _snprintf_s( cmdBuf+pos, cmdBufSize-pos, _TRUNCATE, " -k %i -k %i -k %i", j, j, j );
				}

				// Calculate name
				int nameBufSize = 16+(int)strlen(meshNameStr);
				char* nameBuf = new char[nameBufSize];
				_snprintf_s( nameBuf, nameBufSize, _TRUNCATE, "%s_Spline%i", dataSpline.GetName().data(), i+1 );
				splineNames.push_back( nameBuf );
				splineNamesSize += (int)strlen( nameBuf );

				// Determine whether spline of same name exists, and use -name or -replace option accordingly
				bool exists = (existingNodes.find(std::string(nameBuf)) != existingNodes.end());
				const char* nameFlag = (exists? "replace" : "name");
				pos += _snprintf_s( cmdBuf+pos, cmdBufSize-pos, _TRUNCATE, " -%s \"%s\" ; \n", nameFlag, nameBuf );

				// hack "mel scripting", C++ class apparently doesn't support the -bezier option.
				dag.commandToExecute(cmdBuf);

				delete[] nameBuf;
				delete[] cmdBuf;
			}
		}

		if( splineNames.size()>0 )
		{
			// STEP 3: Generate a planar surface using the splines, resolves with dag.doIt()

			std::string planarName = (dataSpline.GetName() + "_Temp");
			const char* planarNameStr = planarName.data();
			int planarNameSize = (int)strlen(planarNameStr);
			bool exists = (existingNodes.find(planarName) != existingNodes.end());
			if( exists )
			{
				// hack "mel scripting", operations after script-generated splines must also be in script
				dag.commandToExecute(("delete "+planarName+" ; ").data()); // char* to std::string to MString wheee
			}

			int numNames = (int)splineNames.size();
			// reserve 60 chars max for "string $_psd2m_temp1[] = `planarSrf -polygon 1 -name ` ; " prefix and postfix
			// reserve 2 chars max for space around each name, place chars for names themselves
			int cmdBufSize = 60 + planarNameSize + splineNamesSize + (2*numNames);
			char* cmdBuf = new char[cmdBufSize];
			int pos = 0;
			pos = _snprintf_s( cmdBuf, cmdBufSize, _TRUNCATE, "string $_psd2m_temp1[] = `planarSrf -polygon 1 -name %s ", planarNameStr );
			for( int i=0; i<numNames; i++ )
			{
				pos += _snprintf_s( cmdBuf+pos, cmdBufSize-pos, _TRUNCATE, " %s", splineNames[i].data() );
			}
			pos += _snprintf_s( cmdBuf+pos, cmdBufSize-pos, _TRUNCATE, "` ; \n" );

			// hack "mel scripting", operations after script-generated splines must also be in script
			dag.commandToExecute(cmdBuf);

			// TODO: Diagnose why these lines don't work unless combined as a single command
			std::string polycountStr = std::to_string(polycount);
			dag.commandToExecute(
				(
					"{ \n"
					"    string $_psd2m_temp2[] = `listHistory -future true -lv 1 $_psd2m_temp1[1]` ; \n"
					"    setAttr ($_psd2m_temp2[1]+\".polygonType\") 1 ; \n"
					"    setAttr ($_psd2m_temp2[1]+\".format\") 0 ; \n"
					"    setAttr ($_psd2m_temp2[1]+\".polygonCount\") "+polycountStr+" ; \n"
					"}"
				).data()
			);

			// STEP 4: Apply the geometry to the object created earlier, resolves with dag.doIt()

			xformUV transform = graphLayer.GetXFormUV();
			transform.InvertTransform();
			Vector2F uvCenter(0.5f, 0.5f);
			// Calculate UV transform, for the UV projection operator
			// Basically, needs to know scene locations in space of the four corners
			// of the texture plane if it were superimposed over the current geom plane.
			// Depends on size and location of the layer rect within entire texture rect;
			// Here, texture and geom rect are both in abstract units 0.0-1.0, not pixels

			float uvAngle=0, uvScaleX=0, uvScaleY=0;
			transform.GetRotationAndScale(uvAngle,uvScaleX,uvScaleY);
			if( uvAngle!=0 ) // swap x and y scale if rotated
			{
				float temp = uvScaleX;
				uvScaleX = uvScaleY, uvScaleY = temp;
			}

			uvCenter = transform.Transform( Vector2F(0.5,0.5) );
			//uvCenter.x = TransformToMayaCoordinates(uvCenter.x);
			uvCenter.y = TransformToMayaCoordinates(uvCenter.y);

			std::string uvCenterXStr = std::to_string( scaleX*uvCenter.x ), uvCenterYStr = std::to_string( scaleY*uvCenter.y );
			std::string uvScaleXStr = std::to_string( 1.0f/(scaleX*uvScaleX) ),  uvScaleYStr = std::to_string( 1.0f/(scaleY*uvScaleY) );
			std::string uvAngleStr = std::to_string( uvAngle );

			// hack "mel scripting", operations after script-generated splines must also be in script
			dag.commandToExecute(
				(
					"{ \n"
					"    string $_psd2m_temp2[] = `listHistory -future true -lv 1 $_psd2m_temp1[1]` ; \n"
					"    string $_psd2m_temp3[] = `listRelatives -shapes \""+meshName+"\"` ; \n"
					"    string $_psd2m_temp4 = $_psd2m_temp3[0] ; \n"
					"    connectAttr -force ($_psd2m_temp2[1]+\".outputPolygon\") ($_psd2m_temp4+\".inMesh\") ; \n"
					"    polyPlanarProjection -rz 0 -ra "+uvAngleStr+" -pc "+uvCenterXStr+" "+uvCenterYStr+" 0 -imageScale "+uvScaleXStr+" "+uvScaleYStr+" $_psd2m_temp4 ; \n"
					"    delete $_psd2m_temp1[0] ; \n"
					//"    rename -ignoreShape $_psd2m_temp3[0] \""+meshName+"_Shape\" ; \n" // doesn't work, mesh is renamed later
					"}"
				).data()
			);

			// STEP 5: Hide the splines

			for( int i=0; i<numNames; i++ )
			{
				// hack "mel scripting", operations after script-generated splines must also be in script
				dag.commandToExecute(("hide "+splineNames[i]+" ; ").data());
			}

			delete cmdBuf;
		}
		//dag.commandToExecute("} \n"); // close scope

		return mesh;
	}

	//----------------------------------------------------------------------------------------
	MObject MayaMeshScriptor::GetMayaMObject()
	{
		return CurrentObject;
	}

	//----------------------------------------------------------------------------------------
	void MayaMeshScriptor::SetUvs()
	{
		// Example script command
		//dag.commandToExecute("shadingNode - asTexture - isColorManaged -name " + name + "_file file;");
	}

// PUBLIC MAYA MESH SCRIPTOR
#pragma endregion

#pragma region CONSTRUCTOR

	//----------------------------------------------------------------------------------------
	MayaMeshConvertor::MayaMeshConvertor(const GraphLayer& graphLayer)
	{
		GenerateMayaMeshData(graphLayer);
	}

	//----------------------------------------------------------------------------------------
	MayaMeshConvertor::~MayaMeshConvertor() = default;

#pragma endregion

#pragma region PUBLIC MAYA MESH ACCESS

	//----------------------------------------------------------------------------------------
	MObject MayaMeshConvertor::CreateMayaMFnMesh(MObject& parent)
	{
		auto mesh = this->CurrentMesh.create(this->NumVertices,
			this->NumPolygons,
			this->VertexArray,
			this->PolygonCounts,
			this->PolygonConnects,
			parent);
		CurrentObject = mesh;
		return mesh;
	}

	//----------------------------------------------------------------------------------------
	MObject MayaMeshConvertor::GetMayaMObject()
	{
		return CurrentObject;
	}

	//----------------------------------------------------------------------------------------
	void MayaMeshConvertor::SetUvs()
	{
		// Get name
		MStringArray uvNames;
		MStatus status = this->CurrentMesh.getUVSetNames(uvNames);

		// Set position 0 -> 1
		status = this->CurrentMesh.setUVs(this->UArray, this->VArray, &uvNames[0]);
		if (status == MS::kFailure)
		{
			MGlobal::displayInfo("[Set UV]:  " + status.errorString());
		}
		else if (status == MS::kInvalidParameter)
		{
			MGlobal::displayInfo("[Set UV]:  " + status.errorString());
		}

		// Assign UV to polygon
		status = this->CurrentMesh.assignUVs(this->PolygonCounts, this->PolygonConnects, &uvNames[0]);
		if (status == MS::kFailure)
		{
			MGlobal::displayInfo("Assign uv: " + status.errorString());
		}
		else if (status == MS::kInvalidParameter)
		{
			MGlobal::displayInfo("Assign uv: " + status.errorString());
		}

	}

#pragma endregion

#pragma region BUILDER MFNMESH

	//----------------------------------------------------------------------------------------
	void MayaMeshConvertor::AddVertice(float x, float y, int index)
	{
		this->VertexArray[index].x = x;
		this->VertexArray[index].y = y;
		this->VertexArray[index].z = 0.0f;
		this->VertexArray[index].w = 1.0f;
	}

	//----------------------------------------------------------------------------------------
	void MayaMeshConvertor::AddUv(float x, float y, int index)
	{
		this->UArray[index] = x;
		this->VArray[index] = y;
	}

	//----------------------------------------------------------------------------------------
	//
	// MESH CASE: Entire mesh is generated by the plugin (aka Vector Mode), compare with Spline case above
	//
	void MayaMeshConvertor::GenerateMayaMeshData(const GraphLayer& graphLayer)
	{
		const DataMesh& dataMesh = *(graphLayer.Mesh.GetDataMesh()); // surface should be non-null mesh here
		float aspect = dataMesh.GetWidth() / dataMesh.GetHeight();

		float scale = graphLayer.Scale;
		scale *= this->BasedScaleFactor;
		float scaleX = scale * aspect;
		float scaleY = scale;

		// Vertex
		int vertexCount = dataMesh.GetVerticesCount();
		this->NumVertices = vertexCount;
		this->VertexArray.setLength(vertexCount);
		// UV
		this->UArray.setLength(vertexCount);
		this->VArray.setLength(vertexCount);

		xformUV transform = graphLayer.GetXFormUV();
		//if( graphLayer.AtlasIndex<0 )
		//{
		//	// Non-atlas case, transform from PSD layer region to individual texture region
		//	transform.GenerateTransform( graphLayer.LayerRegion, graphLayer.TextureRegion );
		//}
		//else
		//{
		//	// Atlas case, transform from PSD layer region to atlas texture region
		//	transform.GenerateTransform( graphLayer.LayerRegion, graphLayer.AtlasRegion );
		//}

		const std::vector<Vector2F>& vertices = dataMesh.GetVertices();
		int index = 0;
		for (auto it : vertices)
		{
			// geometry coordinate vertex
			const float xPos = it.x;
			const float yPos = TransformToMayaCoordinates(it.y);
			AddVertice(xPos * scaleX, yPos * scaleY, index);
			// uv coordinate vertex
			Vector2F uv = Vector2F(it.x, it.y); 
			uv = transform.Transform( uv );
			uv.y = TransformToMayaCoordinates(uv.y);
			AddUv(uv.x, uv.y, index);
			index++;
		}

		// Poly
		int polygonCount = dataMesh.GetFaceSizesCount();
		this->NumPolygons = polygonCount;
		this->PolygonCounts.setLength(polygonCount);
		const std::vector<int>& facesCount = dataMesh.GetFaceSizes();
		for (int i = 0; i < polygonCount; i++)
		{
			this->PolygonCounts[i] = facesCount[i];
		}

		// Connection
		const int connectionCount = dataMesh.GetFaceVertsCount();
		this->PolygonConnects.setLength(connectionCount);
		const std::vector<int>& facesVerts = dataMesh.GetFaceVerts();
		for (int i = 0; i < connectionCount; i++)
		{
			this->PolygonConnects[i] = facesVerts[i];
		}
	}
	

// BUILDER MFNMESH
#pragma endregion


#pragma region MAYA PLUGIN OUTPUT

	//----------------------------------------------------------------------------------------
	// Helper class for CreateTreeStructure
	// Mapping from layer names to scene nodes
	class MObjectLookup
	{
		public:
			MDagModifier& dagController;
			std::map<std::string, MObject> existingNodes;
			MObjectLookup( MDagModifier& dagController ) : dagController(dagController) {}

			// iterates through all matching nodes in the scene and populates the mapping
			void Init( MFn::Type filter )
			{
				MItDependencyNodes nodeIt(filter, nullptr);
				for (; !nodeIt.isDone(); nodeIt.next())
				{
					#if MAYA_API_VERSION >= 20190000
					if( filter==MFn::Type::kShape )
						existingNodes.try_emplace(std::string(MFnMesh(nodeIt.thisNode()).name().asChar()), nodeIt.thisNode());
					else if( filter==MFn::Type::kTransform )
						existingNodes.try_emplace(std::string(MFnTransform(nodeIt.thisNode()).name().asChar()), nodeIt.thisNode());
					else if( filter==MFn::Type::kLambert )
						existingNodes.try_emplace(std::string(MFnLambertShader(nodeIt.thisNode()).name().asChar()), nodeIt.thisNode());
					#else
					if( filter==MFn::Type::kShape )
						existingNodes.try_emplace(std::string(MFnMesh(nodeIt.item()).name().asChar()), nodeIt.item());
					else if( filter==MFn::Type::kTransform )
						existingNodes.try_emplace(std::string(MFnTransform(nodeIt.item()).name().asChar()), nodeIt.item());
					else if( filter==MFn::Type::kLambert )
						existingNodes.try_emplace(std::string(MFnLambertShader(nodeIt.item()).name().asChar()), nodeIt.item());
					#endif
				}
			}

			// returns true if found, sets the group name params in that case
			// if not found, group name param not changed
			bool FindParentGroup(std::string& groupName, const std::string& childName)
			{
				std::map<std::string, MObject>::iterator it = existingNodes.find(childName);
				if( it!=existingNodes.end() ) // existing node in scene
				{
					MFnDagNode childNode( it->second );
					if( childNode.parentCount()==1 )
					{
						// find parent
						MObject parent = childNode.parent(0);
						MFnDagNode parentNode( parent );
						// find parent name
						MString parentName = parentNode.partialPathName();
						groupName = parentName.asUTF8();
						return true;
					}
				}
				return false;
			}

			// returns true if found, false if created
			bool FindOrCreateGroup(MObject& group, const std::string& groupName )
			{
				if( existingNodes.find(groupName) == existingNodes.end() )
				{
					group = dagController.createNode("transform", MObject());
					dagController.renameNode(group, MString(groupName.c_str()));
					// ensure the group creation is finalized,
					// otherwise next call to FindOrCreateGroup() would not find the group, would create a duplicate
					dagController.doIt();
					// TODO: Safe to modify collection when contents are added after Init() ?
					existingNodes.try_emplace(groupName, group); // existingNodes[groupName] = group; 
					return false;
				}
				else
					group = existingNodes[groupName];
				return true;
			}
	};

	//--------------------------------------------------------------------------------------------------------------------------------------
	void MayaPluginOutput::BeginSession( const IPluginOutputParameters& params )
	{
		// Check if this PSD is the same one we've been using recently ...
		// if not, clear out the cache of shader names, which means we'll be creating new materials,
		// instead of use shaders existing in the scene, which might be from previous PSD
		std::string psdPath = params.FileImportPath();
		std::string psdName = params.PsdName();
		if( (this->psdPath != psdPath) || (this->psdName != psdName) )
		{
			this->psdPath = psdPath;
			this->psdName = psdName;
			materialNameRemap.clear();
		}
	}

	//--------------------------------------------------------------------------------------------------------------------------------------
	void MayaPluginOutput::OutputMesh( const PsdData& psdData, const IPluginOutputParameters& params, const DataSurface& dataSurface, int layerIndex )
	{
		// Not implemented
		// Maya Plugin requires no special handling

		// Scene is creatured during OutputTree()
	}

	//--------------------------------------------------------------------------------------------------------------------------------------
	void MayaPluginOutput::OutputTree( const PsdData& psdData, const IPluginOutputParameters& params, const GroupByNameMap& tree )
	{
		// Maya editor node component creation
		CreateEditorMayaComponents(tree); //progress, 
	}

	//--------------------------------------------------------------------------------------------------------------------------------------
	void MayaPluginOutput::EndSession( const PsdData& data, const IPluginOutputParameters& params )
	{
		// Not implemented
		// Maya Plugin requires no special handling
	}

	//--------------------------------------------------------------------------------------------------------------------------------------
	void MayaPluginOutput::CancelSession( const PsdData& data, const IPluginOutputParameters& params )
	{
		// Not implemented
		// Maya Plugin requires no special handling
	}

	//----------------------------------------------------------------------------------------
	// Param meshes is a DataSurface list, either DataSpline (scripted) or DataMesh (explicit)
	void MayaPluginOutput::CreateEditorMayaComponents( const GroupByNameMap& tree ) //Progress& progress, 
	{
		if (tree.empty()) return;
		MDagModifier dagController;

		MObjectLookup lookupShape( dagController ); // mapping from names to objects for transform nodes in the scene
		lookupShape.Init( MFn::Type::kShape );

		MObjectLookup lookupShader( dagController ); // mapping from names to objects for shading group nodes in the scene
		lookupShader.Init( MFn::Type::kLambert ); // initialize each iteration, because materials created in loop

		MObjectLookup lookupTransform( dagController ); // mapping from names to objects for transform nodes in the scene
		lookupTransform.Init( MFn::Type::kTransform );

		// Shape / Materiel / shader / texture nodes creation and association

		// Iterate through all groups in the Photoshop file ...
		for (auto& groupLayer : tree)
		{
			// Iterate through all layers in the current group ...
			const GraphLayerGroup& graphLayerGroup = groupLayer.second;
			//for(const GraphLayer* const& graphLayerPtr : groupLayer.second.GraphLayers)
			for( int graphLayerIndex=0; graphLayerIndex<graphLayerGroup.GetLayerCount(); graphLayerIndex++ )
			{
				// Assume mesh generation is requested for the current layer, otherwise it wouldn't be in the tree ...

				const GraphLayer* graphLayerPtr = graphLayerGroup[graphLayerIndex];
				if( graphLayerPtr==nullptr ) continue;

				const GraphLayer& graphLayer = *graphLayerPtr;
				const DataSurface& mesh = graphLayer.Mesh;

				//
				std::string parentGroupName;
				if( !lookupTransform.FindParentGroup( parentGroupName, graphLayer.LayerName ) ) {
					parentGroupName = groupLayer.second.GroupName;
				}
				MObject groupTransform;
				lookupTransform.FindOrCreateGroup( groupTransform, parentGroupName );

				const std::string& meshName = graphLayer.LayerName + EditorComponentGenerator::meshNamePostfix;
				std::string materialName = graphLayer.TextureName + EditorComponentGenerator::materialNamePostfix;
				MObject lambert; // material shader

				// check whether material is in the scene, fetching the correct name (accounts for name conflicts)
				bool materialInScene = false;
				bool materialNameUsed = (materialNameRemap.find(materialName) != materialNameRemap.end());
				if( materialNameUsed ) // if the remap doesn't contain this name, we haven't created the material yet
				{
					// fetch correct name, possibly was renamed when created due to name conflict
					materialName = materialNameRemap[materialName];
					materialInScene = (lookupShader.existingNodes.find(materialName) != lookupShader.existingNodes.end());
				}

				// create material not already in the scene
				bool createMaterial = !materialInScene;
				if( createMaterial )
				{
					CreateShapeEditorMaterial(dagController, graphLayer, lambert);
					MFnLambertShader fnLambert(lambert);
					materialNameRemap[ materialName ] = fnLambert.name().asChar();
 				}
				else // shader is already in the scene, reuse it
				{
					lambert = lookupShader.existingNodes[materialName];
				}

				// create or update object
				if (lookupShape.existingNodes.find(meshName) == lookupShape.existingNodes.end())
				{
					CreateShapeEditorComponent(dagController, graphLayer, lambert, groupTransform, createMaterial);
				}
				else
				{
					UpdateShapeEditorComponent(lookupShape.existingNodes[meshName], dagController, graphLayer, lambert);
				}
			}
		}
		dagController.doIt();
	}

	//----------------------------------------------------------------------------------------
	// Creates group transform nodes
	// Does not create transforms for individual mesh nodes, or reassign parenting
	void MayaPluginOutput::CreateMayaTreeStructure( psd_reader::PsdData const& data, const GroupByNameMap& tree )
	{
	}

	//----------------------------------------------------------------------------------------
	void MayaPluginOutput::CreateShapeEditorMaterial( MDagModifier& dag, const GraphLayer& graphLayer,
		MObject& lambert_out)
	{
		const MString layerName = MString( graphLayer.Mesh.GetName().c_str() );
		const MString materialName = EditorComponentGenerator::CreateUniqueName( layerName + EditorComponentGenerator::materialNamePostfix );
		const MString textureName = EditorComponentGenerator::CreateUniqueName( layerName + EditorComponentGenerator::textureNamePostfix );
		const MString filepath = MString(graphLayer.TextureFilepath.c_str());

		// Material creation
		lambert_out = EditorComponentGenerator::CreateMaterialNode( dag, materialName );
		MFnLambertShader fnLambert( lambert_out );
		EditorComponentGenerator::CreatePlaced2DTextureNode( dag, textureName, fnLambert );

		// Set filepath in image teture
		EditorComponentGenerator::UpdateTextureNode( dag, textureName, fnLambert, filepath );
	}

	//----------------------------------------------------------------------------------------
	void MayaPluginOutput::CreateShapeEditorComponent(MDagModifier& dag, const GraphLayer& graphLayer,
		MObject& lambert, MObject& transformParent, bool createShaderGroup )
	{
		const MString layerName = MString( graphLayer.Mesh.GetName().c_str() );
		const MString meshName = EditorComponentGenerator::CreateUniqueName( layerName + EditorComponentGenerator::meshNamePostfix );
		const MString shaderGroupName = EditorComponentGenerator::CreateUniqueName( layerName + EditorComponentGenerator::shaderGroupNamePostfix );

		// Shape generation
		MObject transform = EditorComponentGenerator::CreateTransformShape(dag, meshName, graphLayer.Depth, transformParent);
		MayaMeshGenerator mayaShape = MayaMeshGenerator::CreateMayaMeshGenerator(dag, transform, graphLayer);
		MObject meshObj = mayaShape.GetMayaMObject();

		// Shader Group creation
		// need the mesh here; can't do this earlier in CreateShapeEditorMaterial()
		MFnLambertShader fnLambert(lambert);
		if( createShaderGroup ) // material shader group needs to be created
		{
			EditorComponentGenerator::CreateShaderGroupNode(dag, shaderGroupName, fnLambert, meshObj);
		}
		else // material shader group already existed; add new mesh to the shader group
		{
			EditorComponentGenerator::UpdateShaderGroupNode(dag, shaderGroupName, fnLambert, meshObj);
		}

		// TODO: This leaves two nodes with duplicate names...
		// When re-generating a mesh, this somehow deletes the new transform node,
		// and assign the shape to original transform node (whose name is meshName).
		// This is strange and undocumented, but useful...
		// except the transform and shape should have different names to avoid problems.
		// Calling renameNode() a second time doesn't work, it prevents reassignment
		// to the original transform.  So apparently Maya performs the reassignment
		// after this method returns.  Not fully diagnosed.
		// Thus, currently no easy way to achieve both desired effects:
		// - Reassign shape to the original transform, if any, during re-generation
		// - Ensure shape and transform have different names
		dag.renameNode(meshObj, meshName);

		mayaShape.SetUvs();
	}


	//----------------------------------------------------------------------------------------
	void MayaPluginOutput::UpdateShapeEditorComponent(MObject & mFnMesh, MDagModifier & dag, const GraphLayer& graphLayer,
		MObject& lambert)
	{
		const MString meshName(graphLayer.Mesh.GetName().c_str());
		MObject parent = MFnMesh(mFnMesh).parent(0);

		MStringArray result;
		MGlobal::executeCommand("ls -sets", result);
		MSelectionList * setList = new MSelectionList;
		int length = result.length();
		for (int i = 0; i < length; i++)
		{
			setList->add(result[i]);
		}

		MObject mset;
		bool isShadding = false;
		length = setList->length();
		for (auto i = 0; i < length; i++)
		{
			setList->getDependNode(i, mset);
			MFnSet fnSet(mset);
			if (MFnSet::kRenderableOnly == fnSet.restriction())
			{
				if (fnSet.isMember(mFnMesh))
				{
					isShadding = true;
					break;
				}
			}
		}
		delete setList;
		MGlobal::deleteNode(mFnMesh);

		// Shape generation
		MayaMeshGenerator mayaShape = MayaMeshGenerator::CreateMayaMeshGenerator(dag, parent, graphLayer);
		const MObject meshObj = mayaShape.GetMayaMObject();
		dag.renameNode(meshObj, meshName);
		dag.doIt(); // TODO: maybe disable this, will happen later anyway

		// Add to shadding group.
		if(isShadding)
		{
			MFnSet tmpSG(mset);
			tmpSG.addMember(meshObj);
		}
		dag.doIt(); // TODO: maybe disable this, will happen later anyway

		// Set UV
		mayaShape.SetUvs();
	}



// MAYA PLUGIN OUTPUT
#pragma endregion

} // namespace maya_mesh

