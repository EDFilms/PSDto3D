//----------------------------------------------------------------------------------------------
// ===============================================
//  Copyright (C) 2016, CDRIN.
//  All Rights Reserved.
// ===============================================
//  Unauthorized copying of this file, via any medium is strictly prohibited
//  Proprietary and confidential
//
//  @file meshGeneratorController.cpp
//  @author Fabien Raspail
//  @date 11-11-2016
//
//  @section DESCRIPTION
//
//----------------------------------------------------------------------------------------------


#include "scene_controller/meshGeneratorController.h"

#include "mesh_generator/dataMesh.h"
#include "mesh_generator/linear_mesh/linearMesh.h"
#include "mesh_generator/linear_mesh/bezierCurve.h"
#include "mesh_generator/curve_mesh/curveMeshGenerator.h"
#include "mesh_generator/influence_mesh/influenceMesh.h"
#include "mesh_generator/delaunay_mesh/delaunayMesh.h"
#include "scene_controller/sceneController.h" // for GraphLayer
#include "texture_exporter/textureExporter.h" // for ConvertToMask(), in Influence and Billboard algorithm
#include "interface/ui_wrapper.h" // for version flags, like IsStandaloneVersion




#include "parameters.h"
#include "util/helpers.h"
#include "util/progressJob.h"

// TODO: Need this, otherwise error linking method QByteArray QString::toUtf8() const & Q_REQUIRED_RESULT
//#define QT_COMPILING_QSTRING_COMPAT_CPP // added in project settings

#if defined PSDTO3D_MAYA_VERSION
typedef unsigned long ULONG; // TODO: Remove this; with older Maya vesions, and with Visual Studio 2017 toolset, Qt headers depend on windows.h or require this
#include <QtCore/qfileinfo.h>
#include <maya/MFnLambertShader.h>
#include <maya/MGlobal.h>
#include <maya/MItDependencyNodes.h>
#include <maya/MFnTransform.h>
#include <maya/MFnSet.h>
#include <maya/MDGModifier.h>
#include <maya/MSelectionList.h>
#else
#include "mayaStub.h"
#include <QFileInfo>
#endif
#include <locale>
#include <sstream>

using namespace psd_to_3d;

// Linear mesh is generated by MEL script in Python, instead of by internal algorithm
static bool USE_LINEAR_MESH_SCRIPTOR = true;

// forward declarations
void GenerateDataBillboardMesh_Helper( const PsdData& data, int layerIndex, int alphaThresh, DataMesh& mesh_out );

// debugging functions
#include <QDir>
char debugSaveFolder[1024];
const char* DebugGetSaveFolder() { return debugSaveFolder; }
void DebugSetSaveFolder( const char* path ) { strcpy_s( debugSaveFolder, 1024, path ); }

#pragma region CONSTRUCTOR

//----------------------------------------------------------------------------------------
MeshGeneratorController::MeshGeneratorController( const PsdData& data, const SceneController& scene )
: data(data), scene(scene)
{}

//----------------------------------------------------------------------------------------
MeshGeneratorController::~MeshGeneratorController() = default;

// CONSTRUCTOR
#pragma endregion


#pragma region GENERAL


//----------------------------------------------------------------------------------------
void MeshGeneratorController::GenerateMesh(DataSurface& mesh_out, const LayerParameters& layerParams, int layerIndex, ProgressTask& progressTask) const
{
	LayerParameters::Algorithm algo = layerParams.Algo;

	// delaunay and curve are only suported in the full version, default to billboard otherwise
	if( IsFullVersion==0 && ((algo==LayerParameters::Algorithm::DELAUNAY) || (algo==LayerParameters::Algorithm::CURVE)) )
	{
		algo = LayerParameters::Algorithm::BILLBOARD;
	}

	switch (algo)
	{
	case LayerParameters::Algorithm::LINEAR:
		{
			DataSurface generatedMesh = GenerateDataLinearMesh(data, layerParams, layerIndex, progressTask);
			mesh_out = generatedMesh;
			break;
			// compile error:  //meshes[layerIndex] = GenerateDataLinearMesh(data, blockPath, layerParam);
		}
	case LayerParameters::Algorithm::DELAUNAY:
		{
			DataSurface generatedMesh = GenerateDataDelaunayMesh(data, layerParams, layerIndex, progressTask);
			mesh_out = generatedMesh;
			break;
			// compile error:  //meshes[layerIndex] = GenerateDataDelaunayMesh(data, blockPath, layerParam);
		}
	case LayerParameters::Algorithm::CURVE:
		{
			DataSurface generatedMesh = GenerateDataCurveGridMesh(data, layerParams, layerIndex, progressTask);
			mesh_out = generatedMesh;
			break;
			// compile error:  //meshes[layerIndex] = GenerateDataCurveGridMesh(data, layer, layerParam);
		}
	case LayerParameters::Algorithm::BILLBOARD:
		{
			DataSurface generatedMesh = GenerateDataBillboardMesh(data, layerParams, layerIndex, progressTask);
			mesh_out = generatedMesh;
			break;
		}
	}
}

//----------------------------------------------------------------------------------------
// Creates tree from given meshes
// Tree takes ownership of meshes, empties previous mesh list
void MeshGeneratorController::CreateTreeStructure(
	GroupByNameMap& tree_out, GraphLayerByIndexMap& meshes_in_out, LayerParametersFilter& filter ) const
{
	const GlobalParameters& globalParams = scene.GetGlobalParameters();
	const char* aliasPsdName = globalParams.AliasPsdName.toUtf8().data();
	std::string aliasGroupName = std::string(aliasPsdName);

	std::string defaultGroupName = std::string(globalParams.PsdName.toUtf8().data()) + std::string("_Group_PSDto3D");
	std::string currentGroupName = aliasGroupName.empty() ? defaultGroupName : aliasGroupName;
	std::string rootGroupName = currentGroupName;
	std::vector<std::string> pastGroupName;
	pastGroupName.push_back(currentGroupName);

	// Create group node if object of that name doesn't exist already
	//bool foundRoot = lookup.FindOrCreateGroup( root.Transform, currentGroup );

	// Always create a root node, even though Maya scene might not use it, 
	GraphLayerGroup root;
	root.GroupName = rootGroupName;
	//root.GraphLayers = GraphLayerGroup::LayerList();
	tree_out.insert(std::pair<std::string, GraphLayerGroup>(currentGroupName, root));

	bool anyAddedNodes = false;

	// Create the Transform structure base on the params option and photoshop group
	for( auto const& layer : data.LayerMaskData.Layers )
	{
		int layerIndex = iter_index(layer,data.LayerMaskData.Layers);
		bool layerActive = filter(layerIndex);

		if (globalParams.KeepGroupStructure)
		{
			if( layerActive )
			{
				if (layer.Type == OPEN_FOLDER || layer.Type == CLOSED_FOLDER)
				{
					currentGroupName = layer.LayerName;
					GraphLayerGroup group;
					group.GroupName = currentGroupName;

					tree_out.insert(std::pair<const std::string, GraphLayerGroup>(currentGroupName, group));
					pastGroupName.push_back(currentGroupName);
					continue;
				}

				if (layer.Type == HIDDEN_DIVIDER)
				{
					pastGroupName.pop_back();
					currentGroupName = pastGroupName.back(); //pastGroupName[pastGroupName.size() - 1];
					continue;
				}
			}
		}

		if (layer.Type == TEXTURE_LAYER)
		{
			if( layerActive )
			{
				GraphLayerByIndexMap::iterator iter = meshes_in_out.find(layerIndex);
				if( iter != meshes_in_out.end() )
				{
					GraphLayer& graphLayer_old = iter->second;
					GraphLayer* graphLayer_new = tree_out[currentGroupName].AllocGraphLayer(layerIndex);
					*graphLayer_new = graphLayer_old; // take ownership of mesh, no reference counting
				}
			}
		}
	}

	meshes_in_out.clear(); // Tree takes ownership of meshes, empties previous mesh list
}

//--------------------------------------------------------------------------------------------------------------------------------------
void MeshGeneratorController::ApplyInfluenceLayer(DataMesh& mesh_in_out, int layerIndex, const InfluenceParameters& influenceParams) const
{
	TextureMap tex;
	tex.Init( data.HeaderData.Width, data.HeaderData.Height );

	TextureExporter::ConvertToMask(tex, data.LayerMaskData.Layers[layerIndex], data.HeaderData.Width, data.HeaderData.Height, data.HeaderData.BitsPerPixel);

	MaskData maskData;
	maskData.Data = tex.Buffer();
	maskData.Width = data.HeaderData.Width;
	maskData.Height = data.HeaderData.Height;
	maskData.BytesPerPixel = data.HeaderData.BitsPerPixel / 8;

	InfluenceMesh::SubdivideFaces(mesh_in_out, maskData, influenceParams);
}


// MAYA_PLUGIN
#pragma endregion


#pragma region ALGORITHMS

//----------------------------------------------------------------------------------------
DataSurface MeshGeneratorController::GenerateDataLinearMesh(const PsdData& data, const LayerParameters& layerParams, int layerIndex, ProgressTask& progressTask) const
{
	const LayerData& layer = data.LayerMaskData.Layers[layerIndex];
	const ResourceBlockPath& blockPath = data.ImageResourceData.GetBlockPath(layer.LayerName);

	std::vector<BezierCurve*> curves;
	std::vector<Vector2F*> points;
	boundsUV bounds = boundsUV();

	if( (blockPath.Name.empty()) || !(layerParams.HasLinearSupport) )
		return DataSurface(); // layer does not support Linear mode, abort


	// read bezier Curves
	for (auto pathRecord : blockPath.PathRecords)
	{
		if( (!pathRecord.IsClosedPath) || (pathRecord.Points.size()<3))
		{
			continue;
		}
		BezierCurve* tmpCurve = new BezierCurve();
		tmpCurve->GenerateBezierCurve( pathRecord, Vector2F(0.0f,0.0f), Vector2F(1.0f,1.0f) ); // clamp to valid UV range
		curves.push_back(tmpCurve);
		points.insert(points.end(), tmpCurve->GetCurves().begin(), tmpCurve->GetCurves().end());
	}

	bounds.GenerateBoundingBox(points);

	if( USE_LINEAR_MESH_SCRIPTOR )
	{
		// Linear mesh is generated by script, MEL or Python, instead of by internal algorithm
		DataSpline newSpline = LinearMesh::GenerateSpline( blockPath.Name, layerParams.LinearParameters, bounds, curves, data.HeaderData.Width, data.HeaderData.Height, progressTask );
		return DataSurface( newSpline );
	}

	// Else ... Linear mesh generated by internal algorithm, not by script
	bounds.DisplayBoundingBox();
	DataMesh newMesh = LinearMesh::GenerateMesh( blockPath.Name, layerParams.LinearParameters, bounds, curves, data.HeaderData.Width, data.HeaderData.Height, progressTask );
	if(newMesh.GetFaceVertsCount() == 0)
	{
		int alphaThreshDefault = 4;
		GenerateDataBillboardMesh_Helper( data, layerIndex, alphaThreshDefault, newMesh );
	}
	return DataSurface( newMesh );
}

//----------------------------------------------------------------------------------------
DataSurface MeshGeneratorController::GenerateDataDelaunayMesh(const PsdData& data, const LayerParameters& layerParams, int layerIndex, ProgressTask& progressTask) const
{
	const GlobalParameters& globalParams = scene.GetGlobalParameters();
	const LayerData& layer = data.LayerMaskData.Layers[layerIndex];
	const ResourceBlockPath& blockPath = data.ImageResourceData.GetBlockPath(layer.LayerName);

	const std::vector<unsigned char*>& pixels = layer.ImageContent;
	std::vector<BezierCurve*> curves;
	std::vector<Vector2F*> points;
	boundsUV bounds = boundsUV();

	if( (blockPath.Name.empty()) || !(layerParams.HasDelaunaySupport) )
		return DataSurface(); // layer does not support Linear mode, abort


	// read bezier Curves
	for (auto pathRecord : blockPath.PathRecords)
	{
		if( (!pathRecord.IsClosedPath) || (pathRecord.Points.size()<3) )
		{
			continue;
		}
		BezierCurve* tmpCurve = new BezierCurve();
		tmpCurve->GenerateBezierCurve( pathRecord, Vector2F(0.0f,0.0f), Vector2F(1.0f,1.0f) ); // clamp to valid UV range
		curves.push_back(tmpCurve);
		points.insert(points.end(), tmpCurve->GetCurves().begin(), tmpCurve->GetCurves().end());
	}

	DelaunayMeshInput input( pixels, curves );
	int layerWidth = (layer.AnchorRight-layer.AnchorLeft), layerHeight = (layer.AnchorBottom-layer.AnchorTop);
	input.boundsPixels = boundsPixels( layer.AnchorTop, layer.AnchorRight, layerWidth, layerHeight );
	input.boundsCurves.GenerateBoundingBox(points);
	input.width = data.HeaderData.Width;
	input.height = data.HeaderData.Height;
	input.name = blockPath.Name;

	// data, layerParams.DelaunayParameters, data.HeaderData.Width, data.HeaderData.Height, bounds, curves, progressTask
	DebugSetSaveFolder(
		//globalParams.FileExportPath.toUtf8().data()
		scene.GetGlobalParameters().FileImportPath.toUtf8().data()
	);
	DataMesh newMesh = DelaunayMesh::GenerateMesh( layerParams.DelaunayParameters, input, progressTask ); 

	if( (newMesh.GetFaceVertsCount() == 0) && (!progressTask.IsCancelled()) )
	{
		int alphaThreshDefault = 4;
		GenerateDataBillboardMesh_Helper( data, layerIndex, alphaThreshDefault, newMesh );
	}
	return DataSurface( newMesh );
}

//----------------------------------------------------------------------------------------
DataSurface MeshGeneratorController::GenerateDataCurveGridMesh(const PsdData& data, const LayerParameters& params, int layerIndex, ProgressTask& progressTask) const
{
	const LayerData& layer = data.LayerMaskData.Layers[layerIndex];
	std::vector<Curve> curves;

	if( !(params.HasVectorSupport) )
		return DataSurface(); // layer does not support Curve mode, abort

	// Read bezier curves
	for (auto pathRecord : layer.PathRecords)
	{
		Curve curve = Curve(pathRecord);
		curves.push_back(curve);
	}

	// Generate mesh
	DataMesh newMesh = CurveMeshGenerator::GenerateMesh(curves, layer.LayerName, params.CurveParameters, data.HeaderData.Width, data.HeaderData.Height, progressTask);

	return DataSurface( newMesh );
}

//----------------------------------------------------------------------------------------
DataSurface MeshGeneratorController::GenerateDataBillboardMesh(const PsdData& data, const LayerParameters& params, int layerIndex, ProgressTask& progressTask) const
{
	const LayerData& layer = data.LayerMaskData.Layers[layerIndex];
	DataMesh newMesh;
	GenerateDataBillboardMesh_Helper( data, layerIndex, params.BillboardParameters.BillboardAlphaThresh, newMesh );
	return DataSurface(newMesh);
}

void GenerateDataBillboardMesh_Helper( const PsdData& data, int layerIndex, int alphaThresh, DataMesh& mesh_out )
{
	const LayerData& layer = data.LayerMaskData.Layers[layerIndex];

	int width = layer.AnchorRight-layer.AnchorLeft, height = layer.AnchorBottom-layer.AnchorTop;
	boundsPixels boundsFrame( 0, 0, data.HeaderData.Width, data.HeaderData.Height );
	boundsPixels boundsContent = TextureExporter::GetContentRegion( layer, data.HeaderData.Width, data.HeaderData.Height, data.HeaderData.BitsPerPixel, alphaThresh );	

	mesh_out = DataMesh( layer.LayerName, data.HeaderData.Width, data.HeaderData.Height );
	boundsUV bounds = boundsUV();
	bounds.GenerateBoundingBox( boundsContent, boundsFrame );
	std::vector<Vector2F> vertices;
	vertices.push_back(bounds.TopLeftPoint());
	vertices.push_back(bounds.TopRightPoint());
	vertices.push_back(bounds.BottomRightPoint());
	vertices.push_back(bounds.BottomLeftPoint());
	mesh_out.SetVertices(vertices);
	int indicesFace[]{ 0, 1, 2, 3 };
	mesh_out.AddFace(indicesFace, 4);
	mesh_out.SetBoundsUV(bounds);
}

// ALGORITHMS
#pragma endregion